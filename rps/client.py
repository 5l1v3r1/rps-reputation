"""IP Reputation Client

This module contains the class that should be used to send IP reputation
data to the IP reputation server.

The ReportClient class should be instantiated and a report generated
using the generate_report method, providing a series of reports that
are objects of the classes defined in `report` and `events`.
"""

import hmac
import time
import struct
import socket
import random
import hashlib
import logging

from . import core
from . import reports


class ReportClient(object):
    """Methods to generate and submit IP reputation reports.

    Create an instance of the class with appropriate parameters. Add
    events to the events member, and call send_report() whenever you
    want to try to send a report. If there is not enough data to send,
    then the report will not be sent. If there is pending data when the
    instance is garbage-collected, then a report will be sent at that
    time.
    """

    def __init__(self, timeout, server, username, password, port=core.PORT,
                 software_name=None, software_version=None, end_user=None):
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.settimeout(timeout)
        self.server = server
        self.port = port
        self.username = username
        self.password = password
        self.software_name = software_name
        self.software_version = software_version
        self.end_user = end_user
        self.events = []

    @staticmethod
    def generate_report(subreports, username, password):
        """A report consists of the following items:

            * A one-byte protocol version number.
            * A one-byte number indicating the length of a user name.
            * A sequence of bytes indicating a user name.
            * Eight randomly-generated bytes.
            * A four-byte timestamp in network byte order. This is
              constructed by computing the current time in seconds since
              midnight, January 1 1970 UTC as an unsigned integer, and
              taking the low-order 32 bits of the result.
            * One or more subreports.
            * Finally, ten bytes consisting of the ten most-significant
              bytes (in network byte order) of the SHA1 HMAC digest of
              all data from the version number up to and including the
              EOR byte. The password used to calculate the HMAC is a
              shared secret known by the sensor.
        """
        # A sensor must not send an empty report.
        assert subreports, "A report must contain at least one subreport."
        # There must not be more than one software name subreport.
        name_reports = [subreport for subreport in subreports
                        if isinstance(subreport, reports.SoftwareName)]
        assert len(name_reports) <= 1
        # There must not be more than one software version subreport.
        version_reports = [subreport for subreport in subreports
                           if isinstance(subreport, reports.SoftwareVersion)]
        assert len(version_reports) <= 1
        # If a software version subreport is included, there must also
        # be a software name subreport.
        if version_reports:
            assert name_reports
        username = username.encode("utf8")
        # A username must range from 0 to 63 bytes in length.
        assert len(username) < 64
        random_bytes = [random.randint(0, 255) for dummy in range(8)]
        header = struct.pack("!B%dp8BI" % (len(username) + 1), core.VERSION,
                             username, random_bytes[0], random_bytes[1],
                             random_bytes[2], random_bytes[3],
                             random_bytes[4], random_bytes[5],
                             random_bytes[6], random_bytes[7],
                             int(time.time()))
        subreports = "".join(str(subreport) for subreport in subreports)
        footer = hmac.new(password, header + subreports,
                          hashlib.sha1).digest()[:10]
        return header + subreports + footer

    def send_report(self, force=False):
        """Send a generated report to the specified server."""
        subreports = list(self.events)
        if self.software_name:
            subreports.append(reports.SoftwareName(self.software_name))
        if self.software_version:
            subreports.append(reports.SoftwareVersion(self.software_version))
        if self.end_user:
            subreports.append(reports.EndUser(self.end_user))
        subreports.append(reports.EndOfReport())
        my_report = self.generate_report(subreports, self.username,
                                         self.password)
        # A sensor should include as many events in its report as
        # necessary to make the report size at least 400 bytes. A sensor
        # may send out a shorter report, but must not do so unless
        # failing to do so would result in loss of data or unless it has
        # not sent a report within the last hour.
        if not force and len(my_report) < 400:
            return
        try:
            sent = self.socket.sendto(my_report, 0, (self.server, self.port))
        except socket.error as e:
            log = logging.getLogger("ip-reputation")
            log.info("Unable to submit report: %s", e)
        else:
            if sent == len(my_report):
                self.events = []

    def __del__(self):
        if self.events:
            self.send_report(force=True)

# XXX We could add a simple script that can report event CLI.
# XXX This will also allow for functional tests.
